sort -t, -nk3 user.csv
awk '{print $0|"sort -t',' -nk3 "}' user.csv
cat /dev/null > ~/.bash_history && history -c && exit
clear && printf '\e[3J'
============================================================

clear  
 echo "1. create database "  
 echo "2. view database "  
 echo "3. insert a record "  
 echo "4. delete record "  
 echo "5. modify a record "  
 echo "6. result of particular student "  
 echo "7. exit"  
 echo " enter ur choice "  
 read d  
 case $d in  
 1)  
    echo " enter rollnumber of student "  
   read rn  
   echo " enter name of student "  
   read nm  
   echo " enter marks sanskrit "  
   read sk  
   echo " enter marks english "  
   read eg  
   echo " enter marks hindi "  
   read hn  
   record="$rn $nm $sk $eg $hn "  
   echo $record>stud   
   ;;  
 2) echo " showing database of student"  
   cat stud ;;  
 3)   
   echo " enter rollnumber of student "  
   read rn  
   echo " enter name of student "  
   read nm  
   echo " enter marks sanskrit "  
   read sk  
   echo " enter marks english "  
   read eg  
   echo " enter marks hindi "  
   read hn  
   record="$rn $nm $sk $eg $hn "  
   echo $record>>stud  
    ;;  
 4) echo " enter roll number "  
   read rn  
   grep ^$rn stud  
   if [ $? -ne 0 ]; then  
   echo "record for roll number does not exist "  
   else  
   grep -v $rn stud>>tmp  
   cp tmp stud  
   echo "deletion complete "  
   fi  
   ;;  
 5) echo " enter roll number "  
   read rn1  
   grep ^$rn stud  
   if [ $? -ne 0 ]; then  
   echo "record for roll number does not exist "  
   else  
   echo " enter roll number "  
   read rn  
   echo " enter name of student "  
   read nm  
   echo " enter marks sanskrit "  
   read sk  
   echo " enter marks english "  
   read eg  
   echo " enter marks hindi "  
   read hn  
   record="$rn $nm $sk $eg $hn "  
   var=`grep -n ^$rn1 stud | cut -c 1`  
   echo $var  
   var1=`expr $var - 1`  
   head -$var1 stud>temp  
   echo $record>>temp  
   var3=`wc -l < stud`  
   var2=`expr $var3 - $var `  
   tail -$var2 stud>>temp  
   cp temp stud  
    fi  
 ;;  
 6) echo " enter roll number "  
   read rn  
   echo "printing result "  
   grep ^$rn stud  
 ;;  
 7) ;;  
 * ) echo "enter right choice"  
 esac
 
 
============================================================
Insert:
Use same echo $var>>filename as it has no insert and follows the same pattern

Search:
awk -F 'FieldSeperator'  '$x~/PATTERN/ {print $0}' filename
will print line matching the PATTERN in x th column

awk -F 'FieldSeperator'  '~/PATTERN/ {print $0}' filename
will print line matching the PATTERN

Search: and Replace:
awk -F 'FieldSeperator'  '$x~/PATTERN/  {gsub(/src/,replacement,$x)}1' filename
will search for PATTERN in x th column and replaces src by replacement in x th column

Calculate sum of one column based on unique values of another column:
awk -F 'FieldSeperator' '{a[$x] += $y} END{for (i in a) print i, a[i]}' filename.txt
searches for unique values of x and calculates sum of yth column

Delete
awk -F 'FieldSeperator'  '$x!~/PATTERN/ ' filename
will delete line matching the PATTERN in x th column

Sort:
sort -tFieldSeperator -kx,xn filename
will sort n th column of file if it is a number, if it is a text donot use n

=====================================================================================


1.	Write a Shell script that creates files called Database with a number behind the file name such as Databse1, Database2, Database3… You will have to prompt for the number of files the user will create before entering the while loop.

#!/bin/bash

#Question1

read -p "Enter the number: " n1

for i in `seq -w 1 $n1`
do
  echo Database$i.txt
done

==========================================================================================

2.	Write a shell script to perform the following: 
Read a filename (which contains a list of usernames) and a username from the user, if the file doesn’t exist and print an error message and exit if not, check whether the username is already in the file, and then either print a message stating that the name already existed, or add the name to the end of the list.

#!/bin/bash

read -p "Enter the name of file containing user's data:  " userstxt
if [ -r $userstxt ]; then
	read -p "Enter the name of the student : " name
        content=$(grep -n $name $userstxt|wc -l)
	if [ $content -gt 0 ]; then
	    echo "Name Found"
	else
	    echo "Name Not Found"
	fi

elif [ -f $userstxt ];
then
        echo The file $userstxt exists but is not readable to the script.

else
        echo The file $userstxt does not exist.

fi


==========================================================================================

3.	Write a Shell Script to generate a report on type of files in the current directory
		Sample Output 
  Type of file	Count
Regular files 	    5
Directories 	    2
			-------
#!/bin/bash

noofdir=`ls -l| grep '^d' | wc -l`
nooffil=`ls -l| grep -v '^d' | wc -l`

echo Type of File'\t'		Count
echo Regular Files'\t' 		$nooffil
echo Directories'\t'   		$noofdir

==========================================================================================

4.  	Write a shell script to perform the following: 
Accept any number of file names as command line argument and check if every argument supplied is a file or a directory and report accordingly. Whenever the argument is a file, the number of lines on it is also reported.

#!/bin/bash/
#Give the name of the files as command line argument
filename=$@
for i in $filename
do
	dircount=`ls -l|grep '^d'|grep $i|wc -l`
	filcount=`ls -l|grep -v '^d'|grep $i|wc -l`
	if [ $dircount -ge 1 ]
	then
		echo $i is a directory
	fi
	if [ $filcount -ge 1 ]
	then
		echo $i a file whose number of lines are 
		cat $i | wc -l
	fi
	if [ $dircount -lt 1 -a $filcount -lt 1 ]
	then
		echo $i is neither a file nor a directory
	fi
done


==========================================================================================

5.	Write a Shell Script to generate a report on file permission as shown below from current directory
Detail 	 	Permissions 		  	No of files
User			W				3
Group			R				3
Other 			X				1

#!/bin/bash
rcount=$(getfacl *.*|grep 'r'|grep user::|wc -l)
wcount=$(getfacl *.*|grep 'w'|grep group::|wc -l)
xcount=$(getfacl *.*|grep 'x'|grep other::|wc -l)
echo Detail'\t' Permission'\t' No of files
echo User'\t'   Read'\t' 	$rcount
echo Group'\t'  Write'\t' 	$wcount
echo Other'\t'  Execute'\t' 	$xcount



==========================================================================================

6.	Write a shell script to display a report on length of file names from the current working directory.
Length of file name	No of Files
Single char				1
Two chars				7
More than two chars		2

#!/bin/bash
owc=$(ls ?.*|wc -l)
twc=$(ls ??.*|wc -l)
gtwc=0
ls | awk -F. '{print $1}'>file.txt
var=$(xargs -d '\n' -I% sh -c 'echo % | wc -c' < file.txt)
for i in $var;
do
    if [ $i -gt 3 ]
    then
	gtwc=$((gtwc+1))
    fi
done

echo Single char '\t\t' 	$owc
echo Two char '\t\t'		$twc
echo More than 2 char'\t\t'	$gtwc


==========================================================================================

7.	Write the code for a bash script that deletes files containing more than a given number of bytes.  Suppose that the script arguments are named  sz, f1, f2, f3, ..., fn.   Argument sz is the size (number of bytes) and arguments f1 through fn are the file names.  The script should behave as follows: 
•	If no arguments are given (i.e., sz is missing,) the script should write an error message to stderr and exit with a non‐zero exit status. 
•	If at least the first argument (sz) is present, the script should process each of the file arguments f1 through fn in turn.  For each file argument, 
o	If the file does not exist or is not a regular file, then ignore that argument and continue processing with the next file argument.  Do not print any messages. 
o	If the file does exist and is a regular file (i.e., not a directory or some other kind of special file), then if it contains more than sz bytes it should be deleted. 
o	If there are no file arguments (i.e., only sz is present), the script should terminate without doing anything further. 
Hint: wc –c, bash test condition -f.


#!/bin/bash
#Enter the data  inputnum inputdata as command line argument

inputnum=$1
shift
inputdata=$@
echo ${inputdata}
if [ $inputnum -eq $inputnum 2>/dev/null -o $inputnum -eq 0 2>/dev/null ]
then
      for i in $inputdata
	do
	    echo $i
	    if [ -r $i ]; then
        	size=$(wc -c < $i)
		if [ $size -ge $inputnum ];
		then
			echo Size is larger and needs to be deleted
			rm -i $i
		fi

	    elif [ -f $i ];
		then
        	echo "The file '$i' exists but is not readable to the script."

	    else
        	echo "The file '$i' does not exist."

	    fi
	done
else
   echo First input is not a valid number
fi


==========================================================================================

8.	A small business keeps their employee address book in a plain text file.  Each line in the file contains information about one employee.  The information on each line has three fields separated by exclamation marks (!).  The fields contain the employee name, office number (building and room), and phone number.  
For example: 
VSK!M Block 101!4578 
Ilayaraja N!MCA 403!98422 
Suresh kumar!Canteen 105!4345 
Hari Das!Maths 705!2398
   (This is  sample. Add more record)
Write a shell script that will copy the names and phone numbers of people in a particular building to stdout.  The script has two arguments: the first is the name of the text file containing the information in the format described above; the second is the building name. 

For example, if the first argument to the script is name of a file containing the above data, and the second argument is the string MCA, the script should produce the following output: 
	Ilayaraja N!MCA 403!98422 
These are the only one entry in the original file with offices in MCA.  

Your script should print the message “wrong number of arguments” and exit with a non‐zero exit status if it is not given exactly two arguments.  You do need to check for additional errors: that the input file exists and can be read, etc., if the correct number of arguments is given.  If the building (argument 2) does not exactly match a building name in the file (argument 1) then the script should produce no output. Hints: sed, grep; a pipeline might be useful.


#!/bin/bash
awk -F "!" 'BEGIN{OFS=":";} {print NR,$1,$3}' teachers.txt
Farg=$1
Sarg=$2
#awk -F "!" '~'$2'' $1
if [ "$#" -ne 2 ]
then
	echo '\n\t'Invalid number of arguments '\n\t'Give exactly 2 arguments '\n\t'Program Terminated...'\n\n'
	exit 1
fi
echo First argument: $Farg '\n'Second argument: $Sarg

if [ -r $Farg ]
then
awk -F '!' '$2 ~/'$Sarg'/ {print $2}' $Farg
elif [ -f Farg ]
then
echo File $Farg exists but not readable
else
echo File $Farg is not readable to script
fi


==========================================================================================

9.	The file Employee.txt which has a set of records containing each employee’s code, name, 	designation, department, date of birth and salary. (Note: ‘|’ is used as delimiter to separate 	the fields).
Write MENU DRIVEN shell scripts that use awk scripts to accomplish each of the below task: 
•	Display the highest paid employee for the particular designation obtained as input from the user.
•	Display the details of all the employees who draw salary greater than 8,000. 
•	Display the Employee Name, Designation, Department and Salary of all general managers (Note: Use ‘:’ as field separator to output the records).
•	Calculate the average salary of employees based on designation (Note: Use associative arrays to display average salary of employees in the following format).   
Employee Designation 		Average Salary
********************************************************
Director	      			1200000
Chairman				 50000	
………….			 ……….
******************************************************


#!/bin/bash

highest () {
read -p 'Enter designation :' desgn
echo The one with highest salary ':'
awk -F '|' '$3 ~/'$desgn'/ {print $0}' employee.txt >temp.txt
awk -F '|' -v max=0 '{if($6>max){want=$2; max=$6}}END{print want} ' temp.txt
rm temp.txt
}

sgte () {
echo Employees whose salary '>' 8000
awk -F '|' '$6 > 8000 {print $0}' employee.txt
}

display () {
awk -F '|' 'BEGIN{OFS=":";}  $3~/gm/ {print $2,$3,$4,$6}' employee.txt
}

salary () {
echo Employee designation and salary
awk -F '|' '{arr[$3]+=$6} END {for (i in arr) {print i,arr[i]}}' employee.txt > temp.txt
cat temp.txt
}

choice=1
while [ $choice -ne 0  ]
do
echo '\n\t'1.Highest Salary'\n\t'2.Salary greater than 8000 '\n\t'3.Display data '\n\t'4.Average Salary'\n\t'5.Exit
read -p "Enter your choice : " choice

case $choice in

1)
    highest
;;

2)
    sgte
;;

3)
    display
;;
4)
    salary
;;
5)
    choice=0
;;
esac

done

==========================================================================================

10)	The file Cricket.txt has a set of records describing the performance of some of the well-	known 	cricketers of the recent past in the following format. (Note: ‘|’ is used as delimiter 	to separate the fields).
 
      Write MENU DRIVEN shell scripts that use awk scripts to accomplish each of the below task: 

•	Display the Name, Country, Matches and Bowling Average of all the cricketers who has scored more than 10 centuries (Note: Use ‘:’ as field separator to output the records).
•	Display the details of the cricketers whose runs scored is between 3000 to 6000.
•	Count and display the number of centuries scored by Indian players and players from Pakistan and Australia (use associative arrays).
•	Count the total number of wickets taken country wise and display it in the following format.
    			Country		Total Number of Wickets
***************************************************
AUS			9834
NZ				7825
…..			…….
***************************************************


#!/bin/ksh

htten () {
awk -F "|" 'BEGIN{OFS=":";}$7 >= 10 {print NR,$1,$2,$3,$9}' cricket.txt
}
sbts () {
awk -F "|" 'BEGIN{OFS=":";}$4>=3000&&$4<=6000{print NR,$1,$4}' cricket.txt
}

wickets () {
country="IND AUS PAK"
echo '\t'Country and their total wickets
for i in $country
do
	echo $i
	awk -F '|' '$2 ~ /'$i'/ {sum += $7} END {print sum}' cricket.txt
done
}

display () {
awk -F '|' '{print $2}' cricket.txt > entries
entval=$(awk 'x[$0]++ {$0=""} {print}' entries)
echo '\t'Country and their total centuries
for i in $entval
do
	echo $i
	awk -F '|' '$2 ~ /'$i'/ {sum += $8} END {print sum}' cricket.txt
done
}

choice=1
while [ $choice -ne 0  ]
do
echo '\n\t'1.Higher than 10 centuries'\n\t'2.Score between 3000 t0 6000 '\n\t'3.Display data of IND PAK AUS Players '\n\t'4.Total Wickets'\n\t'5.Exit
read -p "Enter your choice : " choice

case $choice in

1)
    htten #Higher Than ten centuries
;;

2)
    sbts #Score Between 3000 and 6000
;;

3)
    display
;;
4)
    wickets
;;
5)
    choice=0
;;
esac

done


==========================================================================================

11) 	The file Student.dat has a set of records containing each Student’s ID, name, department, city, phone  number, CGPA, exemption details and number of credits earned.  (Note: “|” is used to separate the fields.)
Write a menu driven script to accomplish the following tasks:
•	Display the details of students whose CGPA is between 7 and 9.
•	Display the name(s) of the student(s) who earned the maximum credit.
•	From the record 2 to 5, print the first, third and last field. Use “- “to separate the fields in the output.
•	Calculate the CGPA of students based on department (Note: Use associative arrays to display average CGPA of students in the following format).   
Department 		Average CGPA
******************************************************
CSD	       		 8.65
ECE			 6.25	
IT			 	7.6
******************************************************

#!/bin/ksh
#Use ksh
dcd () {
#awk -F '|' '{print $3}' student.txt
awk -F '|' '{print $3}' student.txt>entries
entval=$(awk 'x[$0]++ {$0=""} {print}' entries)
max=0
echo "The course and their average CGPA are "
for i in $entval
  do
    entcgpa=$(awk -F '|' '$3 ~/'$i'/ {print $5}' student.txt)
    sum=0
    count=0
    for j in $entcgpa
	do
	    sum=`echo "$sum+$j" | bc`
	    count=$((count+1))
	    if [ $j -gt $max ];
	      then
		max=$j
	      fi
	done
     average=`echo "scale=2; $sum/$count" | bc`
     echo $i :  $average
  done
    rm entries
}

display () {
    echo "The entries of 2 nd row to 5 th row of 1,3 and last column are listed below "
    awk -F '|' 'BEGIN{OFS=":";}NR==2, NR==5 {print $1,$3,$NF}' student.txt
}

mcs () {
    entcgpa=$(awk -F '|' '{print $5}' student.txt)
    max=0
    for j in $entcgpa
        do
            if [ $j -gt $max ];
              then
                max=$j
              fi
        done
    echo "The student who got max CGPA is "
    echo $max
    awk -F '|' '$5~/'$max'/ {print $2}' student.txt
}
cbsn () {
    awk -F '|' '{print $5}' student.txt > entcgpa
    entcgpa=$(awk 'x[$0]++ {$0=""} {print}' entcgpa)
    echo " CGPA values between 7 and 9 "
    for j in $entcgpa
      do
        if [[ $j -gt 7 && $j -lt 9 ]];
          then
          echo $j
          fi
     done
}

choice=1
while [ $choice -ne 0  ]
    do
      echo -e '\n\t'1.CGPA between 7 and 9'\n\t'2.Max credit student '\n\t'3.Display data from 2ND to last row '\n\t'4.Display CGPA and Dept'\n\t'5Exit'\n'
      read choice?"Enter your choice : "
      echo -e '\n'
      case $choice in

          1)
          cbsn #CGPA Between Seven and Nine
          ;;

          2)
          mcs #Max Credit Student
          ;;

          3)
          display
          ;;
          4)
          dcd
          ;;
          5)
          choice=0
          ;;
      esac
   done


==========================================================================================
12.	Create an addressbook program using the bourne or bourne-again shell.
It should use functions to perform the required tasks. It should be menu-based, allowing you the options of: 
o	Search address book (by name, mobileno, mailID
o	Add entries
o	Remove / edit entries
o	display a record
(Fields :  id, name, mobile no, mailID, city) – Mobile number should have 10 digits, mailID should be in the correct format (Include validation)

Generate different reports. 


 #!/bin/bash
insert () {
echo inserting values...
awk -v x="$*" 'END{print x} 1'>>addressbook.txt
}

search () {
awk /$1/ addressbook.txt
}

remove () {
echo Deleting...
awk /$1/ addressbook.txt
awk !/$1/ addressbook.txt > newbook.txt && mv newbook.txt addressbook.txt
}

modify () {
old=$1
new=$2
echo $old,$new
awk -v srch="$old" -v repl="$new" '{ sub(srch,repl,$0); print $0 }' addressbook.txt> newbook.txt && mv newbook.txt addressbook.txt
}

choice=1
echo '\n'
while [ $choice -ne 0  ]
do
	echo '\n\t\t'WELCOME TO ADDRESS BOOK '\n'1.Insert'\n'2.Search'\n'3.Delete'\n'4.Modify'\n'5.Exit
	read -p "Enter your choice : " choice
	if [ $choice -eq 1 ]
	then
		echo '\t\n'"Insert( Use Ctrl+D to deselect )"'\n\n'
		read -p "Enter name DOB mail-id mobileno :-  " query
		insert $query

	elif [ $choice -eq 2 ]
	then
		echo "Search.."
		read -p "Enter the name or mobile number or mail id to be searched : " query
		search $query

	elif [ $choice -eq 3 ]
	then
		echo "Delete..."
		read -p "Enter the name or mobile number or mail id to be deleted : " query
		remove $query

	elif [ $choice -eq 4 ]
        then
		echo "Modify..."
		read -p "Enter space seperated old and new entry :- " old new
		echo $old,$new
		modify $old $new

	else
		echo "Exit"
		choice=0
	fi
done


==========================================================

#!/bin/bash
ls
var1=$(ls *.txt)
for i in $var1; do mv $i ${i%.txt}.doc; done
ls


==============================================

#!/bin/bash
directories=$@
length=$#
if [ $length -eq 0 ]
then
	number=$(ls -1|wc -l)
	directories=$(ls -l|grep '^d'|wc -l)
	files=$(ls -l|grep -v '^d'|grep -v '^l'|wc -l)
	links=$(ls -l|grep '^l'|wc -l)
	echo Total count is $number '\n'  no of directories $directories files $files links $links
else
	for i in $directories
	do
		echo $i
		path=$(find / -type d -name $i 2>/dev/null)
		for j in $path
		do
			echo $j
			cd $j
		        directories=$(ls -l|grep '^d'|wc -l)
		        files=$(ls -l|grep -v '^d'|grep -v '^l'|wc -l)
		        links=$(ls -l|grep '^l'|wc -l)
			echo Total count is $number '\n'  no of directories $directories files $files links $links
		done
	done
fi


==========================================================

#!/bin/bash
flag=0
min=2147483647
max=-2147483648
while [ $flag -eq 0 ]
do
	read -p "Enter a number : " num
	if [ $num -eq 0 ]
	then
		flag=1
	else
		if [ $num -gt $max ]
		then
			max=$num
		fi
		if [ $num -lt $min ]
		then
			min=$num
		fi
	fi
done
diff=$(echo $max-$min|bc)
prod=$(echo $max*$min|bc)
echo User'\t': `whoami`
echo Time'\t': `date`
echo Lowest number entered:'\t'$min
echo Highest number entered:'\t'$max
echo Difference between them:'\t'$diff
echo Product between them:'\t'$prod


=======================================================

#!/bin/bash
if [ $# -ne 2 ]
then
	echo Invalid number of arguments
	exit
fi
vehicle=$1
days=$2
vehicle=$(echo $vehicle | tr '[:upper:]' '[:lower:]')

case $vehicle in
car)
	echo car
	cost=$(echo 200*$days|bc)
;;
bus)
	echo bus
        cost=$(echo 1000*$days|bc)

;;
jeep)
	echo jeep
        cost=$(echo 250*$days|bc)

;;
bicycle)
	echo bicycle
        cost=$(echo 50*$days|bc)
;;
*)
	echo Sorry I cant get a $vehicle for you
	exit
;;
esac

echo The cost is $cost for $vehicle


==========================================

#!/bin/bash
who|awk '{print $3,$4,$1,$2,$5}'|sort -n|awk '{print $3,$4,$1,$2,$5}'


=====================================================

#!/bin/bash
grep '^[sS]' student.txt
grep -v '^[s]' student.txt

=======================================================

#!/bin/bash

add () {
	rollno=$1
	name=$2
	shift 2
	marks=$*
	length=$#
	flag=0

	while [ $flag -eq 0  ]
	do
		cd check
		mkdir $rollno
		flag=$(ls -1|grep '[0-9][0-9][a-zA-Z][a-zA-Z][0-9][0-9]$'|wc -l)
		if [ $flag -eq 1 ]
		then
			flag=1
			rm -r $rollno
			cd ..
			break
		fi
		rm -r $rollno
		cd ..
		read -p "Invalid rollno. Enter the rollno again:- " rollno
	done

	flag=0
	while [ $flag -eq 0 ]
	do
		echo Checking $name
		if [[ $name =~ [0-9] ]]
		then
			echo "Name contains number"
			read -p "Enter the name again :- " name
		else
	      		flag=1
   		fi

	done

	while [ $length -ne 5  ]
	do
		echo "Invalid number of arguments for marks.Enter again"
		read -p "Enter your marks again :- " marks
		length=0
		for i in $marks
		do
			length=$((length+1))
		done
	done

	newmarks=$(echo "")
	echo $rollno $name $marks
	for i in $marks
	do
		if [ $i -eq $i 2>/dev/null -a $i -ge 0 -a $i -le 100 ]
		then
			echo $i
		else
			flag=0
			while [ $flag -eq 0 ]
			do
				read -p 'The mark '$i' is invalid. Now enter again :- ' value
				i=$value
				if [ $i -eq $i 2>/dev/null -a $i -ge 0 -a $i -le 100  ]
		                then
					flag=1
				fi
			done
		fi
		newmarks=$(echo $newmarks,$i)
	done
	echo $rollno,$name$newmarks >> student.dat

}

remove () {
	rollno=$1
	awk -F ',' '!/'$rollno'/ {print $0}' student.dat >newbook.dat
	mv newbook.dat student.dat
}

edit () {   echo "edit"
   replace=$1
   rollno=$2
   #sed -i 's/'$1'/'$2'/' student.dat
   awk -F ',' '$1~/'$rollno'/{$3='$replace'; print $0}' student.dat
}

sort () {
	sort -t, -k1 student.dat
}

print () {
   #echo "print"
   echo -e '\n'PSG COLLEGE OF TECHNOLOGY
   echo -e `date +%d:%m:%y`
   awk -F ',' 'BEGIN{OFS=" ";} {total=$3+$4+$5+$6+$7} {print NR,$1,$2,$3,$4,$5,$6,$7,total}' student.dat
   echo -e '\n' Total
   awk -F ',' '{if ($3 >=35) msum+=$3} {if ($4 >=35) psum+=$4}{if ($5 >=35) csum+=$5}{if ($6 >=35) cssum+=$6}{if ($7 >=35) bsum+=$7}END{print msum,psum,csum,cssum,bsum}' student.dat
   echo -e '\n' Average
   awk -F ',' '{if ($3 >=35) msum+=$3} {if ($4 >=35) psum+=$4}{if ($5 >=35) csum+=$5}{if ($6 >=35) cssum+=$6}{if ($7 >=35) bsum+=$7}END{print msum/NR,psum/NR,csum/NR,cssum/NR,bsum/NR}' student.dat
}

choice=1
echo 'Student data management'
while [ $choice -ne 0  ]
do
	echo -e '\n\t'1.Add'\n\t'2.remove'\n\t'3.Edit'\n\t'4.Sort'\n\t'5.Print'\n\t'6.Exit
	read -p "Enter your choice : " choice
	case $choice in
	1)
		echo "Add"
		read -p "Enter rollno :- " rollno
		read -p "Enter name   :- " name
		read -p "Enter marks for 5 subjects :- " marks
		add $rollno $name $marks
	;;
	2)
		echo "Remove"
		read -p "Enter the roll number you want to remove" rollno
	        remove $rollno

	;;
	3)
		echo "Edit"
		read -p "Enter the rollno" rollno
		read -p "Enter the word to be replaced" replace
		edit replace rollno
	;;
	4)
		echo "Sorting..."
		sort
	;;
	5)
		echo "Printing..."
		print
	;;
	6)
		choice=0
	;;
	esac
done


=======================================================================================


